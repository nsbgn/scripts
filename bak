#!/bin/bash
# I use rsync to keep my files synchronised across various devices --- through
# SSH, to SD cards, etcetera. I keep a JSON file to keep this organised. It
# might seem a bit roundabout, but it feels comfier to me than a bare shell
# script. This script will also mount the required devices (use `sudo blkid` 
# to find out UUIDs).
#
# For example, the ~/.bak.json might look like this:
#
# [ { "id": "mp3"
#   , "note": "For a hardware MP3 player using FAT32. I use fatsort to keep it sorted."
#   , "mount": { "dir":"/media/mp3", "uuid":"18a3c1b4-4cde-49dd-a4f7-bbf55f72a318" }
#   , "local": "~/data/audio/music"
#   , "remote": "/media/mp3/Music"
#   , "arguments": 
#       [ "-rltD", "--modify-window=1", "--size-only", "--include=*.mp3"
#       , "--include=folder.jpg", "--include=*/", "--exclude=*"
#       ]
#   } ]
#
# Dependencies: rsync, pmount, fatsort, jq

# Location of configuration file
CONFIG="$HOME/.bak.json"


# Obtain configuration (set TARGET environment variable accordingly; otherwise
# the first is used)
JSON="$( jq \
    --arg entry "$TARGET" \
    'if $entry == "" then .[0] else .[] | select(.id == $entry) end' \
    < "$CONFIG")"

if ! [ "$JSON" ]; then
    echo "Backup target \"$TARGET\" was not found."
    exit 1
fi


# Set relevant variables from configuration
read -r LOCAL REMOTE MOUNT UUID < <(echo "$JSON" | jq -r '[.local,.remote,.mount.dir//empty,.mount.uuid//empty] | @tsv')
readarray -t FILES < <(echo "$JSON" | jq -r '.files // empty | .[]')
readarray -t OPTS < <(echo "$JSON" | jq -r '.arguments // empty | .[]')


# If there are no target files, there should still be something synchronised,
# namely, the directories themselves
if [ ${#FILES[@]} -eq 0 ]; then
    FILES=( "" )
fi


# Expand tildes
LOCAL="${LOCAL/#\~/$HOME}"
REMOTE="${REMOTE/#\~/$HOME}"
MOUNT="${MOUNT/#\~/$HOME}"


# Do a dry run first, then asks for confirmation before rsyncing
function rsync-confirm {
    if [ "$MOUNT" ] && ! mountpoint -q "$MOUNT"; then
        echo "\"$MOUNT\" is not a mount point."
        exit 1
    fi
    echo rsync "$@"
    rsync --dry-run "$@"
    read -r -p "Are you sure? [y/N] " confirmation
    case $confirmation in
        [yY][eE][sS]|[yY])
            rsync "$@"
            ;;
        *)
            exit 0
            ;;
    esac
}


for arg in "$@"; do
    case $arg in
        -i|--pull)
            rsync-confirm --progress \
                "${OPTS[@]}" \
                "${FILES[@]/#/$REMOTE/}" \
                "$LOCAL/"
            sync
        ;;
        -o|--push)
            rsync-confirm --progress \
                "${OPTS[@]}" \
                "${FILES[@]/#/$LOCAL/}" \
                "$REMOTE/"
            sync
        ;;
        -m|--mount)
            pmount /dev/disk/by-uuid/"$UUID" "$MOUNT"
        ;;
        -u|--umount)
            pumount "$MOUNT"
        ;;
        *)
        echo "Unknown command line argument."
        exit 1
        ;;
    esac
done

# This is a work-in-progress.
# The idea is to first skip files that are newer on the receiver, then report
# which files were skipped and whether or not you want to replace them, too.
#function summary {
# diff 
#    <(rsync --dry-run --itemize-changes          "${OPTS[@]}" "${LOCAL}" "${REMOTE}") 
#    <(rsync --dry-run --itemize-changes --update "${OPTS[@]}" "${LOCAL}" "${REMOTE}") 
#}

